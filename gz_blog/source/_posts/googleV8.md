---
title: googleV8
date: 2020-11-27 15:47:52
tags: 
    - googleV8
categories: 
    - googleV8
---

## 如何学习谷歌高性能 JavaScript 引擎V8

* 什么是 V8？
  V8 是 JavaScript 虚拟机的一种。我们可以简单地把 JavaScript 虚拟机理解成是一个翻译程序，将人类能够理解的编程语言 JavaScript，翻译成机器能够理解的机器语言。如下图所示：
  ![JavaScript引擎](v8_01.jpg)

  上图中，中间的“黑盒”就是 JavaScript 引擎 V8。目前市面上有很多种 JavaScript 引擎，诸如 SpiderMonkey、V8、JavaScriptCore 等。而由谷歌开发的开源项目 V8 是当下使用最广泛的 JavaScript 虚拟机，全球有超过 25 亿台安卓设备，而这些设备中都使用了 Chrome 浏览器，所以我们写的 JavaScript 应用，大都跑在 V8 上。
  在 V8 出现之前，所有的 JavaScript 虚拟机所采用的都是解释执行的方式，这是 JavaScript 执行速度过慢的一个主要原因。而 V8 率先引入了即时编译（JIT）的双轮驱动的设计，这是一种权衡策略，混合编译执行和解释执行这两种手段，给 JavaScript 的执行速度带来了极大的提升
<!-- more -->
  在 V8 出现之前，所有的 JavaScript 虚拟机所采用的都是解释执行的方式，这是 JavaScript 执行速度过慢的一个主要原因。而 V8 率先引入了即时编译（JIT）的双轮驱动的设计，这是一种权衡策略，混合编译执行和解释执行这两种手段，给 JavaScript 的执行速度带来了极大的提升。

  V8 出现之后，各大厂商也都在自己的 JavaScript 虚拟机中引入了 JIT 机制，所以你会看到目前市面上 JavaScript 虚拟机都有着类似的架构。另外，V8 也是早于其他虚拟机引入了惰性编译、内联缓存、隐藏类等机制，进一步优化了 JavaScript 代码的编译执行效率

  V8 的主要功能，就是结合 JavaScript 语言的特性和本质来编译执行它

* 学习V8
  
  V8 的编译流水线，其完整流程
  ![v8编译流水线](v8_02.jpg)
  编译流水线本身并不复杂，但是其中涉及到了很多技术，诸如 JIT、延迟解析、隐藏类、内联缓存等等。这些技术决定着一段 JavaScript 代码能否正常执行，以及代码的执行效率。

  V8 中使用的隐藏类（Hide Class），这是将 JavaScript 中动态类型转换为静态类型的一种技术，可以消除动态类型的语言执行速度过慢的问题，如果你熟悉 V8 的工作机制，在你编写 JavaScript 时，就能充分利用好隐藏类这种强大的优化特性，写出更加高效的代码

  V8 实现了 JavaScript 代码的惰性解析，目的是为了加速代码的启动速度，通过对惰性解析机制的学习，你可以优化你的代码更加适应这个机制，从而提高程序性能
  
  除了要分析编译流水线，我们还需要了解另外两个非常重要的特性，那就是 ***事件循环系统*** 和 ***垃圾回收机制***。

  事件循环系统和 JavaScript 中的难点——异步编程特性紧密相关。JavaScript 是单线程的，JavaScript 代码都是在一个线程上执行，如果同一时间发送了多个 JavaScript 执行的请求，就需要排队，也就是进行异步编程。
  V8 的事件循环系统会调度这些排队任务，保证 JavaScript 代码被 V8 有序地执行。因此也可以说，事件循环系统就是 V8 的心脏，它驱动了 V8 的持续工作。

  JavaScript 是一种自动垃圾回收的语言，V8 在执行垃圾回收时，会占用主线程的资源，如果我们编写的程序频繁触发垃圾回收，那么无疑会阻塞主线程，这也是我们经常会遇到的一个问题。你需要知道 V8 是如何分配内存数据的，以及这些数据是如何被回收的，打通整个链路，建立完整的系统，当下次遇到内存问题时，就知道如何去排查了
  ![v8](all_v8.jpg)

{% pullquote mindmap mindmap-md %}
- googlV8
	- v8的基础环境
		- 堆空间
			- 树状存储结构
			- 存储对象
			- 存储闭包函数引用的原生类型
		- 栈空间
			- 先进后出
			- 存储原生类型
		- 全局执行上下文
			- 初始化this
			- 全局作用域
			- 全局对象
		- 宿主环境
			- 宿主类型
				- 浏览器
				- node
				- 其他宿主
			- 内置
				- 内置函数
				- 内置对象
					- 浏览器 window
					- node.global
		- 事件循环系统
			- 消息队列
			- 任务调度系统
	- v8执行流程
		- 词法分析
			- 扫描源码
			- 分割源码中的字符
			- 输出Token
		- 语法分析
			- 基于词法分析出来的Token分析语法错误，给出提示
			- 输出AST
			- 输出作用域
				 - 词法作用域规则
				 - 包含当前域中的对象和函数
			- 惰性编译
				- 推迟解析函数中的代码
				- 到执行函数时再解析
				- 默认只解析顶层代码
			- 预解析器
				- 快速查看函数
				- 检查函数的语法是否正确
				- 检查是否有闭包函数
					- 如果函数引用了父函数中的变量，那么必须将引用的变量分配到堆中
		- 字节码
			- v8执行javascript过程中的中间代码
			- 根据作用域和AST生成
			- 机器代码的抽象
			- v8虚拟机的指令集
			- 字节码缓存
				- 降低内存
				- 提升执行速度
		- 解释执行字节码
			- 两种经典的虚拟机架构
				- 寄存器的虚拟机
				  - 累加器
				  	- 计算过程中临时变量存放在累加器中
				  - 寄存器
				  	- PC寄存器—— 用来存放下一条字节码指令
					- 通用寄存器—— 用来存放数据
				  - 堆和栈
				  	- 堆存放对象等数据
					- 栈管理函数调用关系
				- 基于栈架构的虚拟机
					- 寄存器
						- pc寄存器
						- 通用寄存器
					- 栈
						- 管理函数调用
						- 存放临时变量
					- 堆
						- 存放对象等数据
				- v8才用的是寄存器的虚拟机
					- 充分使用累加器
					- 字节码指令集的编程风格和基于栈的有差异
					- 顺序执行字节码
		- 优化字节码执行速度
			- 为什么解释执行慢
				- javascript 是动态语言
				- v8事先不知道类型的形状
				- 动态查找属性
				- 执行之前需要编译
			- 内联缓存
				- 缓存对象形状
				- 下次执行相同类型时，直接使用该形态来快速定位属性
		- 即时编译
			- 监视器
				- 监视解释器的执行过程
				- 发现热点代码
				- 将热点代码提交给编辑器优化
			- 编译器
				- 编译器会编译热点代码
				- 并优化编译后的二进制机器代码
				- 二进制代码能够被高效执行
			- 隐藏类
				- 提取代码中的对象的形状
				- 并记录具体形状
				- 通过形状快速定位对象属性
			- 反优化
				- 对象的形状被动态修改了
				- 隐藏类失效
				- 触发反优化机制
	- 事件循环系统
		- 什么是事件循环系统
			- javascript是单线程模式
			- 单线程同时只能执行一个任务
			- 有新的任务就需要排队执行
			- 引入消息队列
			- 消息队列中的任务是宏任务
			- 任务调度器
				- 循环读取消息队列中的任务
				- 分派给指定的任务处理器
		- 异步编程
			- 回掉函数模式
				- 以回掉函数的方式编写异步代码
				- 可读性差
				- 代码难维护
				- 回掉地狱
			- Promise 模式
				- 半同步的方式编写异步代码
				- 使用微任务
				- 改造了回调函数
				- 可读性提升
			- async/await 模式
				- 同步的方式编写异步代码
				- 使用微任务
				- 使用了协程
				- 可读性大幅提升
				- 原理复杂
	- javascript设计思想
		- 函数一等公民
			- 函数拥有普通类型的特性
				- 可以作为参数
				- 可以作为返回值
				- 可以赋值给一个变量
			- 基于对象设计
				- 基本类型
					- String
					- Number
					- Boolean
					- Null
					- Undefined
					- Symbol
					- BigInt
				- 对象类型
					- 普通对象
					- 函数
					- 数组
			- 对象是动态的
				- 可以在运行时改变对象属性
			- 支持闭包
				- 函数即对象
				- 函数可以作为返回值
				- 子函数可以引用父函数内部的变量
				- 父函数返回子函数，子函数引用父函数的变量需要一同打包带走
			- 函数表达式
				- 函数声明
					- 在编译阶段，会将声明的函数转换成函数对象
					- 函数声明会被变量提升
				- 函数表达式
					- 在编译阶段，不会对函数表达式做任何操作
					- 立即调用函数表达式
		- 类型系统和垃圾回收
			- 类型系统
				- 什么是类型系统
					- 内存中的二进制是没有类型的
					- 我们可以强制给一组二进制赋予类型信息
					- 类型信息为许多操作提供隐含的上下文
						- 两个整数类型相加
						- 两个字符串类型相加
					- 类型系统限制了不合法的类型操作
						- 1+ '2' js 中合法
						- 1+ '2' Python 中不合法
				- 不同的类型如何存储
					- 对象存储在堆中
					- 基本类型存储在栈中
				- 传值和传引用
					- 原生类型一律传值
					- 对象类型一律传引用
			- 垃圾回收
				- 采用自动垃圾回收策略
		- 作用域
			- 源代码中定义变量的区域
			- 静态作用域（写代码的时候静态确认下来的）
			- 动态作用域 （和函数调用的位置有关）
			- javascript 是基于静态作用域
			- 作用域链(沿着多个作用域，查找变量的链路)
				- 函数级作用域
				- 函数内声明的变量生成周期和函数绑定
				- 块级作用域
				- 变量和函数声明
		- 原型链继承
			- 原型
				- 每个对象都有一个原型属性
				- 原型也是一个对象
				- 通过__proto__指向原型对象
			- 原型链(查找对象属性的链路)
				- 先在当前的属性中查找
				- 再在原型对象中查找
				- 再在原型的原型对象中查找直到 顶层Object的原型对象
			- new 关键字
	- 垃圾回收系统
		- 什么是自动垃圾回收系统
			- 自动跟踪正在使用的对象并回收不再使用的对象
		- 回收方式
			- 手动分配和回收
				- 显示分配内存
				- 手动回收内存
			- 智能指针
				- 记住每个对象被引用的次数
				- 当引用计数为0 时，便自动回收该对象
			- 自动内存管理
				- 所有被引用的元素都用一个根元素
				- 每次从根向下遍历，没有被遍历到的数据视为垃圾数据
		- 代记假说
			- 大部分对象在内存中存活的时间短
			- 不死的对象会会活的更久
		- 分代收集
			- 新生代存放新对象那
			- 老生代存放老对象
		- 垃圾回收器
			- 副垃圾回收器(负责新生代的垃圾回收)
			- 主垃圾回收器（负责老生代的代码回收）
		- 垃圾回收流程
			- 通用流程
				- 回收非活动对象占用的内存
				- 整理内存碎片
			- 副垃圾回收器
				- Scavenge 算法
				- 新生代的对象和空闲区域
				- 对象晋升策略
			- 主垃圾回收器
				- 标记清除算法
				- 标记整理算法
				- 大对象
				- 晋升的对象
			- 全停顿
				- 垃圾回收操作会占用主线程
				- 会阻塞主线程
					- 引发问题
						- 代码不规范，触发频繁的垃圾回收，主业务被阻塞
					- 优化方法
						- 优化代码
							- 减少触发垃圾回收次数
							- 采用增量垃圾回收
						- v8 采用并行垃圾回收策略
{% endpullquote %}